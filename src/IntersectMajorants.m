function [ beta1vec, beta2vec ] = IntersectMajorants( b1_a, b2_a, b1_b, b2_b, n_interp )
%% INTERSECTMAJORANTS intersects the critical beta1/beta2 domain
% boundary of two matrices; subsequent application can generate
% the boundary of the critical domain of a set of matrices
%
% The intersection is generated by linear interpolation of both
% critical domains on a common grid and an intersection of this
% discrete representation. The parameter n_interp should be at least
% the number of points determined by BETADOMAINP2.
%
% NOTE: in order to generate the intersection for a set of matrices
% a log2-complexity can be achieved by intersecting pairs and then
% intersecting the intersections etc.
% 
% INPUTS       (e.g. from BETADOMAINP2)
% b1_a, b2_a   beta1 and beta2 of the first matrix (or set of matrices)
% b1_b, b2_b   beta1 and beta2 of the second matrix (or set of matrices)
% n_interp     number of points used to interpolate data on a common grid
%
% OUTPUTS
% beta1vec     new beta1 values
% beta2vec     new beta2 values
%
% See also SHARPLOEWNERMAJORANTP2, BETADOMAINP2, PLOTCRITICALB2
%
%
% related to the article
% Sharp Loewner majorants for a set of symmetric matrices
% by Felix Fritzen and Mauricio Fernandez
% [ submitted to AMCS (Aug 2018) ]
%
% CONTENT OF THIS FILE
% - examples for the two-parametric matrix majorization (se Fig. X, Y)
% - illustrates how to access the different tools
%
% LICENSE
% This software is distributed under the GNU GPL v3.
% An active contribution to this software is welcome (see CONTACT below).
%
% Further licensing information is contained in the file 'license'
% distributed with this code.
%
% CONTACT
% Felix Fritzen        felix.fritzen@mechbau.uni-stuttgart.de
% Mauricio Fernandez   mauricio.fernandez@mechbau.uni-stuttgart.de
% http://www.mechbau.uni-stuttgart.de/EMMA
%
% GITHUB
% This software is hosted on GITHUB. It is accessible via
% https://github.com/EMMA-Group/LoewnerMajorant
%
%% find lower bound for beta1
b1_min = max( b1_a(1), b1_b(1) );
b1_max = max( b1_a(end), b1_b(end) );

%% interpolate data on common (fine) grid
if( ~exist('n_interp', 'var') )
    n = 5*max( length(b1_a), length(b1_b) );
else
    n = n_interp;
end
% interpolation of b2 from vectors a and b

beta1vec = linspace(b1_min, b1_max, n);
b2_a_int = interp1( b1_a, b2_a, beta1vec, 'pchip' );
b2_b_int = interp1( b1_b, b2_b, beta1vec, 'pchip' );
beta2vec = max( b2_a_int, b2_b_int );
